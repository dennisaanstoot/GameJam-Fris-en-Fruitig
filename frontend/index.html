<!DOCTYPE HTML>
<html>
<head>
	<title>Fris en fruitig</title>
	<style>
		body {
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
			background-color: #000;
		}

		canvas {
			width: 800px;
			height: 600px;
			display: block;
			margin: 10px auto;
		}
	</style>
	<script src="pixi.js"></script>
	<script src="jquery.js"></script>
</head>
<body>
	<div id="connectForm">
		<input type="text" id="name">
		<button id="connect">Connect</button>
	</div>
	<script>
		$(document).ready(function()
		{
			var name, renderer, cooldown_start_time, loadingbar_width;
			stage = new PIXI.Stage(0xff0000); // has to be in main scope for callbacks to work
			loadingbar = new PIXI.Graphics(); // see above
			var game_width = 800;
			var game_height = 600;
			var shoot_enabled = false;
			var socket = new WebSocket('ws://130.89.231.61:9000','fris_en_fruitig');

			$("#connect").click(function()
			{
				var name = "Rien";//$("#name").val();
				send_to_server("connect "+name);
				$("#connectForm").remove();
			});

			socket.onopen = function() {
				console.log("Connection established");
				$("body").css('background-color', '#0f0');
				$("#connect").click();
			}

			socket.onerror = function() {
				$("body").css('background-color', '#f00');
			}

			socket.onclose = function() {
				console.log("Connection closed");
				$("body").css('background-color', '#000');
			}

			var message;
			socket.onmessage = function(event) {
				console.log(event);
				message = event.data.split(" ");
				console.log(message);
				switch (message[0])
				{
					case "ok":
						wait_screen();
						break;

					case "start":
						start_game(message);
						break;

					case "frame":
						draw_frame(message);
						break;
				}
			}

			function wait_screen() {
				var waiting_screen = new PIXI.Text("Waiting for other players",{font: 'bold 36px Georgia', fill: 'white'});
				waiting_screen.anchor.x = waiting_screen.anchor.y = 0.5;
				waiting_screen.position.x = map_width/2;
				waiting_screen.position.y = map_height/2;
				map.addChild(waiting_screen);
			}

			function start_game(message) {
				var map_width = message[1];
				var map_height = message[2];
				var player_amount = message[3];

				$("body").css('background-color', '#000');
				renderer = PIXI.autoDetectRenderer(game_width, game_height);

				var lava = PIXI.Texture.fromImage("sprites/lava.png");
				var game_background = new PIXI.Sprite(lava);
				game_background.width = game_width;
				game_background.height = game_height;
				stage.addChild(game_background);

				//playing screen
				var map = new PIXI.DisplayObjectContainer();
				map.width = map_width;
				map.height = map_height;
				map.position.x = ((game_width/2)-(map_width)/2);
				map.position.y = ((game_height/2)-(map_height)/2);
				stage.addChild(map);

				//playing screen background
				var floor = PIXI.Texture.fromImage("sprites/floor.png");
				var background = new PIXI.Sprite(floor);
				background.width = map_width;
				background.height = map_height;
				map.addChild(background);


				var player_amount_text = new PIXI.Text("Players: "+player_amount, {font: 'normal 12px Georgia', fill: 'white'});
				player_amount_text.anchor.x = player_amount_text.anchor.y = 1;
				player_amount_text.position.x = map_width-5;
				player_amount_text.position.y = map_height-5;
				map.addChild(player_amount_text);

				document.body.appendChild(renderer.view);
				draw();

				shoot_enabled = true;
			}

			function draw_frame(message) {
				message.splice(0,1);
				var entities = JSON.parse(message);

				var player_texture = PIXI.Texture.fromImage("sprites/soldier.png");
				var tree_texture = PIXI.Texture.fromImage("sprites/tree.png");
				var bullet_texture = PIXI.Texture.fromImage("sprites/bullet.png");

				player_counter = 2; // semi-random value to generate nice colours for players
				for (var i = 0; i < entities.length; i++)
				{
					var entity = entities[i];
					switch(entity[0])
					{
						case "player":
							var player = new PIXI.Sprite(player_texture);
							player.tint = 1/player_counter * 0xffffff;
							player.anchor.x = player.anchor.y = 0.5;
							player.position.x = entity.x;
							player.position.y = entity.y;
							player.rotation = entity.angle;
							player.width = player.height = 10;
							map.addChild(player);
							player_counter += 3;
							break;

						case "tree":
							var tree = new PIXI.Sprite(tree_texture);
							tree.anchor.x = tree.anchor.y = 0.5;
							tree.position.x = entity.x;
							tree.position.y = entity.y;
							tree.width = tree.height = 20;
							map.addChild(tree);
							break;

						case "bullet":
							var bullet = new PIXI.Sprite(bullet_texture);
							bullet.anchor.x = bullet.anchor.y = 0.5;
							bullet.position.x = entity.x;
							bullet.position.y = entity.y;
							bullet.position = entity.angle;
							bullet.width = bullet.height = 5;
							map.addChild(bullet);
							break;
					}
				}
				draw();
			}
			
			function draw() {
				var now = Date.now();
				loadingbar.width = (now-cooldown_start_time)*loadingbar_width;
				requestAnimFrame(draw);
				renderer.render(stage);
			}

			stage.click = function() {
				var mouse_position = stage.getMousePosition();
				send_to_server("input l "+mouse_position.x+" "+mouse_position.y);
			}

			stage.rightclick = function() {
				if (shoot_enabled)
				{
					var mouse_position = stage.getMousePosition();
					send_to_server("input r "+mouse_position.x+" "+mouse_position.y);
					shootCooldown();
					setTimeout(enableShoot(),3000);
				}
			}

			function shootCooldown()
			{
				cooldown_start_time = Date.now();
				shoot_enabled = false;
				loadingbar.beginFill(0x1D428A);
				loadingbar.drawRect(0,map_height, 0, 15);
				loadingbar_width = 60;
				map.addChild(loadingbar);
			}

			function enableShoot()
			{
				shoot_enabled = true;
				map.removeChild(loadingbar);
			}

			function send_to_server(message)
			{
				console.log("Send: "+message);
				socket.send(message);
			}
		});
	</script>
</body>
</html>